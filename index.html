<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gobblet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Roboto', sans-serif;
      background-color: black;
      background-image: url("assets/images/Gobblet-backround.png");
      background-repeat: no-repeat;
      background-position: center center;
      background-size: auto;
      overflow-x: hidden; /* prevent sideways scrolling if wide images */
    }
    h1 {
      text-align: center;
      margin: 1em 0 0.5em 0;
      color: #fff;
    }
    .game-layout {
      display: flex;
      justify-content: center; /* center everything horizontally */
      align-items: flex-start;
      gap: 10px; /* narrower gap */
      max-width: 800px; /* narrower max width to bring columns in more */
      margin: 0 auto;
      padding: 0 5px 20px;
    }
    .supply-container {
      width: 70px; /* narrower supply column */
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .supply-container h2 {
      margin-bottom: 10px;
      font-size: 1.0em;
      color: #fff;
    }
    .supply {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }
    .board-container {
      flex: 1;
      margin-top: 20px;
      position: relative;
    }
    #turn-indicator {
      margin-bottom: 10px;
      font-size: 1em;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
      text-align: center;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(4, 60px); /* smaller squares */
      grid-gap: 6px; /* a bit smaller gap */
      justify-content: center;
      margin-bottom: 20px;
    }
    .square {
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.2);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 4px;
      position: relative;
      transition: background 0.2s ease;
    }
    .square:hover {
      background: rgba(255,255,255,0.3);
    }
    /* Board pieces: absolute in center of their square */
    .piece-board {
      position: absolute;
      transform: translate(-50%, -50%);
      cursor: grab;
    }
    /* Supply pieces: normal flow in a column */
    .piece-supply {
      position: relative;
      cursor: grab;
    }
    /* Common piece styling */
    .piece {
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
    }
    /* SIZE-BASED SHADING:
       Larger sizes => darker (lower brightness) */
    .size1 {
      width: 25px; height: 25px; font-size: 0.7em;
      filter: brightness(100%);
    }
    .size2 {
      width: 35px; height: 35px; font-size: 0.8em;
      filter: brightness(90%);
    }
    .size3 {
      width: 45px; height: 45px; font-size: 0.9em;
      filter: brightness(80%);
    }
    .size4 {
      width: 55px; height: 55px; font-size: 1em;
      filter: brightness(70%);
    }
    .player1 { background: #e74c3c; }
    .player2 { background: #3498db; }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }
    .controls button {
      background: #3498db;
      color: #fff;
      border: none;
      padding: 0.7em 1.2em;
      font-size: 1em;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s ease;
      margin: 5px;
    }
    .controls button:hover {
      background: #2980b9;
    }
    /* Ghost piece for dragging. We'll set pointer-events to none so it doesn't interrupt events. */
    .drag-ghost {
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      opacity: 0.8;
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <h1>Gobblet</h1>
  <div class="game-layout">
    <!-- Left Supply (Player 1) -->
    <div class="supply-container">
      <h2>Player 1</h2>
      <div id="player1-supply" class="supply"></div>
    </div>

    <!-- Board in Center -->
    <div class="board-container">
      <!-- This heading updates to "Player 1's Turn" or "Player 2's Turn" -->
      <h2 id="turn-indicator">Player 1's Turn</h2>
      <div id="board" class="board"></div>
    </div>

    <!-- Right Supply (Player 2) -->
    <div class="supply-container">
      <h2>Player 2</h2>
      <div id="player2-supply" class="supply"></div>
    </div>
  </div>

  <div class="controls">
    <button id="reset-btn">Reset Game</button>
    <button id="undo-btn">Undo</button>
    <button id="play-music-btn">Play Music</button>
    <button id="pause-music-btn">Pause Music</button>
  </div>
  <audio id="bg-music" src="assets/music/ambient.mp3" autoplay loop></audio>

  <script>
    /********************************************************************
     * GLOBALS AND DOM ELEMENTS
     ********************************************************************/
    let board = [];
    const ROWS = 4;
    const COLS = 4;
    const player1Pieces = [];
    const player2Pieces = [];
    let currentPlayer = 1;
    let draggingPiece = null;    // The piece data {id,player,size,from...}
    let draggingElement = null;  // The DOM element being dragged (the ghost)
    let originSquare = null;     // If we picked from the board, store (r,c) so we can revert

    const boardEl = document.getElementById('board');
    const player1SupplyEl = document.getElementById('player1-supply');
    const player2SupplyEl = document.getElementById('player2-supply');
    const resetBtn = document.getElementById('reset-btn');
    const undoBtn = document.getElementById('undo-btn');
    const bgMusic = document.getElementById('bg-music');
    const playMusicBtn = document.getElementById('play-music-btn');
    const pauseMusicBtn = document.getElementById('pause-music-btn');
    const turnIndicatorEl = document.getElementById('turn-indicator');

    let historyStack = [];
    let botWorker = new Worker("botWorker.js");

    /********************************************************************
     * INIT / RENDER
     ********************************************************************/
    function initBoard() {
      board = [];
      for (let r = 0; r < ROWS; r++) {
        board[r] = [];
        for (let c = 0; c < COLS; c++) {
          board[r][c] = [];
        }
      }
    }

    function initSupplies() {
      player1Pieces.length = 0;
      player2Pieces.length = 0;
      let idCounter1 = 1;
      let idCounter2 = 1;

      function addPiecesForPlayer(player, size) {
        for (let i = 0; i < 3; i++) {
          let piece = {
            id: player === 1 ? `P1-${idCounter1++}` : `P2-${idCounter2++}`,
            player,
            size,
            used: false
          };
          if (player === 1) player1Pieces.push(piece);
          else player2Pieces.push(piece);
        }
      }
      [1,2,3,4].forEach(sz => {
        addPiecesForPlayer(1, sz);
        addPiecesForPlayer(2, sz);
      });
    }

    function initGame() {
      initBoard();
      initSupplies();
      currentPlayer = 1;
      updateTurnIndicator();
      historyStack = [];

      renderAll();
      saveHistory();
    }

    function renderAll() {
      renderBoard();
      renderSupplies();
    }

    function renderBoard() {
      boardEl.innerHTML = '';
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const squareDiv = document.createElement('div');
          squareDiv.classList.add('square');
          squareDiv.id = `square-${r}-${c}`;

          const stack = board[r][c];
          if (stack.length > 0) {
            // top piece
            const topPiece = stack[stack.length - 1];
            const pieceEl = createPieceElement(topPiece, /* fromBoard= */true);
            // center it in the square
            pieceEl.style.top = '50%';
            pieceEl.style.left = '50%';
            // For dragging
            pieceEl.onmousedown = (e) => startDragFromBoard(e, topPiece, r, c);
            squareDiv.appendChild(pieceEl);
          }
          boardEl.appendChild(squareDiv);
        }
      }
    }

    function renderSupplies() {
      player1SupplyEl.innerHTML = '';
      player2SupplyEl.innerHTML = '';

      player1Pieces.forEach(piece => {
        if (!piece.used) {
          const el = createPieceElement(piece, /* fromBoard= */ false);
          el.onmousedown = (e) => startDragFromSupply(e, piece);
          player1SupplyEl.appendChild(el);
        }
      });
      player2Pieces.forEach(piece => {
        if (!piece.used) {
          const el = createPieceElement(piece, false);
          el.onmousedown = (e) => startDragFromSupply(e, piece);
          player2SupplyEl.appendChild(el);
        }
      });
    }

    function createPieceElement(piece, fromBoard) {
      // fromBoard => piece is placed in the board, so absolute + centered
      // otherwise => piece is in the supply
      const el = document.createElement('div');
      el.classList.add('piece', `player${piece.player}`, `size${piece.size}`);

      if (fromBoard) {
        el.classList.add('piece-board');
      } else {
        el.classList.add('piece-supply');
      }
      el.textContent = piece.size;
      return el;
    }

    function updateTurnIndicator() {
      turnIndicatorEl.textContent = `Player ${currentPlayer}'s Turn`;
    }

    /********************************************************************
     * DRAG & DROP LOGIC
     ********************************************************************/
    function startDragFromSupply(e, piece) {
      if (piece.player !== currentPlayer) {
        alert(`It's Player ${currentPlayer}'s turn, not yours!`);
        return;
      }
      beginDrag(e, {
        id: piece.id,
        player: piece.player,
        size: piece.size,
        from: 'supply'
      });
    }

    function startDragFromBoard(e, piece, r, c) {
      if (piece.player !== currentPlayer) {
        alert(`Top piece belongs to Player ${piece.player}, not you!`);
        return;
      }
      board[r][c].pop(); // remove from board so it disappears
      originSquare = {r, c};
      renderBoard(); // re-render so the piece is removed visually

      beginDrag(e, {
        id: piece.id,
        player: piece.player,
        size: piece.size,
        from: 'board'
      });
    }

    function beginDrag(e, pieceInfo) {
      e.preventDefault();
      if (draggingPiece) return;

      draggingPiece = pieceInfo;
      // create ghost
      draggingElement = document.createElement('div');
      draggingElement.className = `piece drag-ghost player${pieceInfo.player} size${pieceInfo.size}`;
      draggingElement.textContent = pieceInfo.size;
      document.body.appendChild(draggingElement);

      positionGhost(e.pageX, e.pageY);
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    }

    function onMouseMove(e) {
      if (!draggingElement) return;
      positionGhost(e.pageX, e.pageY);
    }

    function onMouseUp(e) {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);

      if (!draggingPiece) return;
      const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
      if (dropTarget && dropTarget.classList.contains('square')) {
        const [r, c] = parseSquareId(dropTarget.id);
        if (canPlacePiece(r, c, draggingPiece)) {
          placePiece(r, c, draggingPiece);
          cleanupDrag();
          return;
        } else {
          alert("Can't place here: piece is too small or invalid move.");
        }
      }
      // revert
      revertDraggingPiece();
      cleanupDrag();
    }

    function cleanupDrag() {
      if (draggingElement && draggingElement.parentNode) {
        draggingElement.parentNode.removeChild(draggingElement);
      }
      draggingElement = null;
      draggingPiece = null;
      originSquare = null;
    }

    function positionGhost(x, y) {
      if (!draggingElement) return;
      draggingElement.style.left = (x - draggingElement.offsetWidth / 2) + 'px';
      draggingElement.style.top = (y - draggingElement.offsetHeight / 2) + 'px';
    }

    function parseSquareId(id) {
      // id = "square-r-c"
      const parts = id.split('-');
      return [ parseInt(parts[1]), parseInt(parts[2]) ];
    }

    function canPlacePiece(r, c, pieceInfo) {
      let stack = board[r][c];
      if (stack.length > 0) {
        let topPiece = stack[stack.length - 1];
        if (pieceInfo.size <= topPiece.size) {
          return false;
        }
      }
      return true;
    }

    function placePiece(r, c, pieceInfo) {
      if (pieceInfo.from === 'supply') {
        if (pieceInfo.player === 1) {
          const p = player1Pieces.find(x => x.id === pieceInfo.id);
          if (p) p.used = true;
        } else {
          const p = player2Pieces.find(x => x.id === pieceInfo.id);
          if (p) p.used = true;
        }
      }
      board[r][c].push({
        player: pieceInfo.player,
        size: pieceInfo.size,
        id: pieceInfo.id
      });

      renderAll();
      // Wait a frame so piece is visible
      window.requestAnimationFrame(() => {
        if (checkWin(pieceInfo.player)) {
          alert(`Player ${pieceInfo.player} wins!`);
          disableAllMoves();
        } else {
          if (pieceInfo.player === currentPlayer) {
            currentPlayer = (currentPlayer === 1 ? 2 : 1);
          }
          updateTurnIndicator();
          saveHistory();
          if (currentPlayer === 2) {
            startBotTurn();
          }
        }
      });
    }

    function revertDraggingPiece() {
      if (!draggingPiece) return;
      if (draggingPiece.from === 'board' && originSquare) {
        board[originSquare.r][originSquare.c].push({
          player: draggingPiece.player,
          size: draggingPiece.size,
          id: draggingPiece.id
        });
      }
      renderAll();
    }

    /********************************************************************
     * BOT TURN
     ********************************************************************/
    function startBotTurn() {
      let state = {
        board: board,
        supply1: player1Pieces,
        supply2: player2Pieces,
        currentPlayer: currentPlayer
      };
      botWorker.postMessage({ state: state, timeLimit: 10 });
      botWorker.onmessage = function(e) {
        const { move, error } = e.data;
        if (error) {
          console.error("Bot error:", error);
          return;
        }
        if (move) {
          applyBotMove(move);
        }
      };
    }

    function applyBotMove(move) {
      if (move.type === 'supply') {
        let supply = (move.piece.player === 1) ? player1Pieces : player2Pieces;
        let p = supply.find(x => x.id === move.piece.id);
        if (p) p.used = true;
      } else if (move.type === 'board') {
        let st = board[move.from[0]][move.from[1]];
        if (st.length > 0) st.pop();
      }
      board[move.to[0]][move.to[1]].push({
        player: move.piece.player,
        size: move.piece.size,
        id: move.piece.id
      });
      renderAll();
      window.requestAnimationFrame(() => {
        if (checkWin(move.piece.player)) {
          alert(`Player ${move.piece.player} wins!`);
          disableAllMoves();
        } else {
          currentPlayer = 1;
          updateTurnIndicator();
          saveHistory();
        }
      });
    }

    /********************************************************************
     * WIN CHECK / DISABLE
     ********************************************************************/
    function checkWin(player) {
      let topGrid = [];
      for (let r = 0; r < ROWS; r++) {
        topGrid[r] = [];
        for (let c = 0; c < COLS; c++) {
          let stack = board[r][c];
          topGrid[r][c] = (stack.length > 0) ? stack[stack.length - 1].player : 0;
        }
      }
      // check rows
      for (let r = 0; r < ROWS; r++) {
        if (topGrid[r].every(p => p === player)) return true;
      }
      // check cols
      for (let c = 0; c < COLS; c++) {
        let colVals = [];
        for (let r = 0; r < ROWS; r++) {
          colVals.push(topGrid[r][c]);
        }
        if (colVals.every(p => p === player)) return true;
      }
      // diag1
      let diag1 = [topGrid[0][0], topGrid[1][1], topGrid[2][2], topGrid[3][3]];
      if (diag1.every(p => p === player)) return true;
      // diag2
      let diag2 = [topGrid[0][3], topGrid[1][2], topGrid[2][1], topGrid[3][0]];
      if (diag2.every(p => p === player)) return true;
      return false;
    }

    function disableAllMoves() {
      // remove mousedown from supply pieces
      let supplyPieces = player1SupplyEl.querySelectorAll('.piece-supply');
      supplyPieces.forEach(el => el.onmousedown = null);
      supplyPieces = player2SupplyEl.querySelectorAll('.piece-supply');
      supplyPieces.forEach(el => el.onmousedown = null);

      // remove from board pieces
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          let sq = document.getElementById(`square-${r}-${c}`);
          if (sq) {
            let child = sq.querySelector('.piece-board');
            if (child) {
              child.onmousedown = null;
            }
          }
        }
      }
    }

    /********************************************************************
     * UNDO
     ********************************************************************/
    function saveHistory() {
      let stateObj = {
        board: JSON.parse(JSON.stringify(board)),
        player1Pieces: JSON.parse(JSON.stringify(player1Pieces)),
        player2Pieces: JSON.parse(JSON.stringify(player2Pieces)),
        currentPlayer
      };
      historyStack.push(stateObj);
    }

    function undoLastMove() {
      if (historyStack.length <= 1) {
        alert('No moves to undo!');
        return;
      }
      historyStack.pop();
      let prevState = historyStack[historyStack.length - 1];
      board = JSON.parse(JSON.stringify(prevState.board));
      player1Pieces.splice(0, player1Pieces.length, ...prevState.player1Pieces);
      player2Pieces.splice(0, player2Pieces.length, ...prevState.player2Pieces);
      currentPlayer = prevState.currentPlayer;

      renderAll();
      updateTurnIndicator();
    }

    /********************************************************************
     * EVENTS
     ********************************************************************/
    resetBtn.addEventListener('click', initGame);
    undoBtn.addEventListener('click', undoLastMove);
    playMusicBtn.addEventListener('click', () => bgMusic.play());
    pauseMusicBtn.addEventListener('click', () => bgMusic.pause());

    window.onload = initGame;
  </script>
</body>
</html>
